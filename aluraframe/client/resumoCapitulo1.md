CAPITULO 1 - RESUMO ==============================================================================

Vamos revisar o que estudamos at√© aqui: vimos a cria√ß√£o de uma classe, utilizando novos recursos JavaScript que favorecem a implementa√ß√£o do paradigma orientado a objeto. Vimos tamb√©m que uma classe possui um constructor com os quais definimos atributos - que chamamos de propriedades - e que podemos materializar uma abstra√ß√£o do mundo real usando um modelo, por meio de uma classe. Outro assunto abordado √© que podemos passar par√¢metros no construtor de uma classe e dessa forma, garantindo que no momento em que a inst√¢ncia de uma classe √© criada, j√° tenha todos os dados necess√°rios.

Por conven√ß√£o, adotamos que os atributos privados devem usar o prefixo _ (underline), indicando para o desenvolvedor que ele s√≥ pode acess√°-lo. Vimos como adicionar m√©todos nas classes, e estes, sim, podem acessar os atributos privados.

Apresentamos uma maneira de criar um atributo, que na pr√°tica √© um m√©todo, e ao acess√°-lo, podemos executar o c√≥digo. Moral da hist√≥ria: temos um m√©todo que conseguimos acessar como uma propriedade, bastando ser antecedido pela palavra especial get, desta forma, estar√≠amos gerando um getter. Quem acessa a sua classe acredita que se trata de uma propriedade, mas na verdade, trata-se por "debaixo dos panos" de um m√©todo.

No entanto, isto n√£o era suficiente para garantir a integridade da nossa negocia√ß√£o, que n√£o pode ser alterada. Por isso, usamos o Object.freeze() para congelar um objeto depois de criado. Como Object.freeze() √© shallow (raso), ele ser√° aplicado nas propriedades do objeto, mas as propriedades que s√£o objetos n√£o ser√£o todas congeladas. A a√ß√£o ficar√° apenas na superf√≠cie. Para resolver esta quest√£o, falamos um pouco sobre programa√ß√£o defensiva. Quando algu√©m tentar acessar a data, n√≥s retornaremos uma nova data. Fizemos o mesmo com o construtor e com isso, evitamos que algu√©m consiga de fora da classe alterar algum item do estado interno.

O que vimos foi relevante porque o modelo √© uma das coisas mais importantes quando desenvolvemos o sistema. Agora que temos o modelo pronto, a aplica√ß√£o poder√° crescer, tendo-o como base. No fim, deixamos a sugest√£o da ado√ß√£o de um novo h√°bito: substituir nas declara√ß√µes de vari√°veis o uso de var por let, que permite um escopo de bloco e evita que as mesmas vazem para um escopo global. Antes do ES6, em JavaScript, era comum o uso de fun√ß√µes para a cria√ß√£o de um escopo para a vari√°vel.üéß